<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React-2 | 前端知识</title>
    <meta name="generator" content="VuePress 1.5.1">
    
    <meta name="description" content="这是一个总结前端知识的网站鸭">
    <link rel="preload" href="/assets/css/0.styles.8fbd8908.css" as="style"><link rel="preload" href="/assets/js/app.4a18b501.js" as="script"><link rel="preload" href="/assets/js/2.57b2d9b0.js" as="script"><link rel="preload" href="/assets/js/7.0a1fa2bb.js" as="script"><link rel="prefetch" href="/assets/js/3.d07fa4b8.js"><link rel="prefetch" href="/assets/js/4.1a9da7e5.js"><link rel="prefetch" href="/assets/js/5.f288ef04.js"><link rel="prefetch" href="/assets/js/6.b757856b.js"><link rel="prefetch" href="/assets/js/8.4639948f.js"><link rel="prefetch" href="/assets/js/9.f39db2ca.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8fbd8908.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端知识</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="https://google.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  External
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="https://google.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  External
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前言</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/" aria-current="page" class="sidebar-link">关于我</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>React</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/react/react1.html" class="sidebar-link">React-1</a></li><li><a href="/react/react2.html" aria-current="page" class="active sidebar-link">React-2</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react/react2.html#上节课重点内容回顾" class="sidebar-link">上节课重点内容回顾</a></li><li class="sidebar-sub-header"><a href="/react/react2.html#课程目标" class="sidebar-link">课程目标</a></li><li class="sidebar-sub-header"><a href="/react/react2.html#课程内容" class="sidebar-link">课程内容</a></li><li class="sidebar-sub-header"><a href="/react/react2.html#下节课内容" class="sidebar-link">下节课内容</a></li><li class="sidebar-sub-header"><a href="/react/react2.html#练习" class="sidebar-link">练习</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>面试题</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react-2"><a href="#react-2" class="header-anchor">#</a> React-2</h1> <h2 id="上节课重点内容回顾"><a href="#上节课重点内容回顾" class="header-anchor">#</a> 上节课重点内容回顾</h2> <ul><li>JSX 注意事项
<ul><li>必须有,且只有一个顶层的包含元素 - React.Fragment</li> <li>JSX 不是html，很多属性在编写时不一样
<ul><li>className</li> <li>style -- 值接收对象</li></ul></li> <li>列表渲染时，必须有 key 值</li> <li>在 jsx 所有标签必须闭合</li> <li>组件的首字母一定大写，标签一定要小写</li></ul></li> <li>类组件
<ul><li>组件类必须继承 <strong>React.Component</strong></li> <li>组件类必须有 <strong>render</strong> 方法</li></ul></li> <li>事件
<ul><li>大小写问题</li> <li>this 问题</li></ul></li> <li>props 和 state
<ul><li>props 父组件传递过来的参数 -- 在组件内部不能修改 props</li> <li>state 组件自身状态</li></ul></li></ul> <h2 id="课程目标"><a href="#课程目标" class="header-anchor">#</a> 课程目标</h2> <ul><li>掌握 setState 的各种使用情况</li> <li>掌握 React 组件间通信</li> <li>掌握 React 组件的生命周期</li> <li>掌握受控组件的使用</li></ul> <h2 id="课程内容"><a href="#课程内容" class="header-anchor">#</a> 课程内容</h2> <h3 id="state-和-setstate"><a href="#state-和-setstate" class="header-anchor">#</a> state 和 setState</h3> <ul><li>setState(updater, [callback])
<ul><li>updater: 更新数据 FUNCTION/OBJECT</li> <li>callback: 更新成功后的回调 FUNCTION</li> <li>异步:react通常会集齐一批需要更新的组件，然后一次性更新来保证渲染的性能</li> <li>浅合并 Objecr.assign()</li> <li>调用 setState 之后，会触发生命周期，重新渲染组件</li></ul></li></ul> <h3 id="组件间通信"><a href="#组件间通信" class="header-anchor">#</a> 组件间通信</h3> <p>在 React.js 中，数据是从上自下流动（传递）的，也就是一个父组件可以把它的 state / props 通过 props 传递给它的子组件，但是子组件不能修改 props - React.js 是单向数据流，如果子组件需要修改父组件状态（数据），是通过回调函数方式来完成的。</p> <ul><li>父级向子级通信
把数据添加子组件的属性中，然后子组件中从props属性中，获取父级传递过来的数据</li> <li>子级向父级通信
在父级中定义相关的数据操作方法(或其他回调), 把该方法传递给子级，在子级中调用该方法父级传递消息</li> <li>案例：完善好友列表</li></ul> <h4 id="跨组件通信-context-扩展"><a href="#跨组件通信-context-扩展" class="header-anchor">#</a> 跨组件通信 context - 扩展</h4> <ul><li>React.createContext(defaultValue);
{ Consumer, Provider } = createContext(defaultValue)</li> <li>Context.Provider 在父组件调用 Provider 传递数据
<ul><li>value 要传递的数据</li></ul></li> <li>接收数据
<ul><li>class.contextType = Context;</li> <li>static contextType = Context;
<ul><li>this.context;</li></ul></li> <li>Context.Consumer
<code>&lt;Consumer&gt; {(props)=&gt;{ console.log(props); return &lt;div&gt;&lt;/div&gt; }} &lt;/Consumer&gt;</code> <strong>注意在使用不熟练时，最好不要再项目中使用 context，context一般给第三方库使用</strong></li></ul></li></ul> <h3 id="组件的生命周期"><a href="#组件的生命周期" class="header-anchor">#</a> 组件的生命周期</h3> <p>所谓的生命周期就是指某个事物从开始到结束的各个阶段，当然在 React.js 中指的是组件从创建到销毁的过程，React.js 在这个过程中的不同阶段调用的函数，通过这些函数，我们可以更加精确的对组件进行控制，前面我们一直在使用的 render 函数其实就是组件生命周期渲染阶段执行的函数</p> <h4 id="生命周期演变"><a href="#生命周期演变" class="header-anchor">#</a> 生命周期演变</h4> <h5 id="之前（react-16-3-之前）"><a href="#之前（react-16-3-之前）" class="header-anchor">#</a> 之前（React 16.3 之前）</h5> <ul><li>挂载阶段
<ul><li>constructor</li> <li>componentWillMount</li> <li>render</li> <li>componentDidMount</li></ul></li> <li>更新阶段
<ul><li>父组件更新引起组件更新
<ul><li>componentWillReceiveProps(nextProps)</li> <li>shouldComponentUpdate(nextProps, nextState)</li> <li>componentWillUpdate(nextProps, nextState)</li> <li>render</li> <li>componentDidUpdate(prevProps, prevState)</li></ul></li> <li>组件自身更新
<ul><li>shouldComponentUpdate</li> <li>componentWillUpdate</li> <li>render</li> <li>componentDidUpdate</li></ul></li></ul></li> <li>卸载阶段
<ul><li>componentWillUnmount</li></ul></li></ul> <h5 id="现在"><a href="#现在" class="header-anchor">#</a> 现在</h5> <ul><li><p>挂载阶段</p> <ul><li>constructor</li> <li>static getDerivedStateFromProps(props, state)
<ul><li>注意 this 问题</li></ul></li> <li>render</li> <li>componentDidMount -- 处理副作用(请求)</li></ul></li> <li><p>更新阶段
- static getDerivedStateFromProps(props, state)
- shouldComponentUpdate()  -- 判断是否跟新
- render()
- getSnapshotBeforeUpdate()
- componentDidUpdate() -- 处理副作用(请求)</p></li> <li><p>卸载阶段</p> <ul><li>componentWillUnmount  -- 删除添加在全局的一些信息或操作</li></ul></li> <li><p>错误处理</p> <ul><li>static getDerivedStateFromError()</li> <li>componentDidCatch(error, info)
参考：http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</li></ul></li></ul> <h3 id="生命周期函数详解"><a href="#生命周期函数详解" class="header-anchor">#</a> 生命周期函数详解</h3> <h4 id="constructor-props"><a href="#constructor-props" class="header-anchor">#</a> constructor(props)</h4> <p>类的构造函数，也是组件初始化函数，一般情况下，我们会在这个阶段做一些初始化的工作</p> <ul><li>初始化 state</li> <li>处理事件绑定函数的 this</li></ul> <h4 id="render"><a href="#render" class="header-anchor">#</a> render()</h4> <p>render 方法是 Class 组件必须实现的方法</p> <h4 id="static-getderivedstatefromprops-props-state"><a href="#static-getderivedstatefromprops-props-state" class="header-anchor">#</a> static getDerivedStateFromProps(props, state)</h4> <p>该方法会在 render 方法之前调用，无论是挂载阶段还是更新阶段，它的存在只有一个目的：让组件在 props 变化时更新 state</p> <h4 id="componentdidmount"><a href="#componentdidmount" class="header-anchor">#</a> componentDidMount()</h4> <p>在组件挂载后（render 的内容插入 DOM 树中）调用。通常在这个阶段，我们可以：</p> <ul><li>操作 DOM 节点</li> <li>发送请求</li></ul> <h4 id="shouldcomponentupdate-nextprops-nextstate"><a href="#shouldcomponentupdate-nextprops-nextstate" class="header-anchor">#</a> shouldComponentUpdate(nextProps, nextState)</h4> <p>发生在更新阶段，getDerivedStateFromProps 之后，render 之前，该函数会返回一个布尔值，决定了后续是否执行 render，首次渲染不会调用该函数</p> <h4 id="getsnapshotbeforeupdate-prevprops-prevstate"><a href="#getsnapshotbeforeupdate-prevprops-prevstate" class="header-anchor">#</a> getSnapshotBeforeUpdate(prevProps, prevState)</h4> <p>该方法在 render() 之后，但是在输出到 DOM 之前执行，用来获取渲染之前的快照。当我们想在当前一次更新前获取上次的 DOM 状态，可以在这里进行处理，该函数的返回值将作为参数传递给下个生命周期函数 componentDidUpdate</p> <blockquote><p>该函数并不常用。</p></blockquote> <h4 id="componentdidupdate"><a href="#componentdidupdate" class="header-anchor">#</a> componentDidUpdate()</h4> <p>该函数会在 DOM 更新后立即调用，首次渲染不会调用该方法。我们可以在这个函数中对渲染后的 DOM 进行操作</p> <h4 id="componentwillunmount"><a href="#componentwillunmount" class="header-anchor">#</a> componentWillUnmount()</h4> <p>该方法会在组件卸载及销毁前调用，我们可以在这里做一些清理工作，如：组件内的定时器、未完成的请求等</p> <h3 id="错误处理"><a href="#错误处理" class="header-anchor">#</a> 错误处理</h3> <p>当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法</p> <ul><li>static getDerivedStateFromError()</li> <li>componentDidCatch()</li></ul> <h3 id="受控组件"><a href="#受控组件" class="header-anchor">#</a> 受控组件</h3> <p>受控组件: 让 input 的value  和我们 state 保持一致
非受控组件: 我们不需要同步 value 值(defaultValue，defaultChecked)</p> <h3 id="todolist-初实现"><a href="#todolist-初实现" class="header-anchor">#</a> todoList 初实现</h3> <h2 id="下节课内容"><a href="#下节课内容" class="header-anchor">#</a> 下节课内容</h2> <ul><li>掌握React其他 API 使用：PureComponent、ref、children、dangerouslySetInnerHTML、key</li> <li>掌握函数式组件及常见 hooks 的使用</li> <li>可以独立开发基于Hooks 或 Component 的 todoList 应用</li></ul> <h2 id="练习"><a href="#练习" class="header-anchor">#</a> 练习</h2> <p>把好友列表和todo都自己做一遍</p> <p>todo:
- 添加todo
- 修改完成状态
- 统计未完成
- 统计已完成
- 清除已完成</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/react/react1.html" class="prev">
        React-1
      </a></span> <span class="next"><a href="/js/string对象.html">
        string对象
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.4a18b501.js" defer></script><script src="/assets/js/2.57b2d9b0.js" defer></script><script src="/assets/js/7.0a1fa2bb.js" defer></script>
  </body>
</html>
