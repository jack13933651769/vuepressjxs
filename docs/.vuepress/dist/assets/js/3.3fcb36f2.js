(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{348:function(t,a,e){t.exports=e.p+"assets/img/vue.42de5b0b.jpg"},349:function(t,a,e){t.exports=e.p+"assets/img/vue1.612e2a12.png"},350:function(t,a,e){t.exports=e.p+"assets/img/vue2.6cb4375c.jpg"},357:function(t,a,e){"use strict";e.r(a);var s=e(43),n=Object(s.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"vue面试题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue面试题"}},[t._v("#")]),t._v(" Vue面试题")]),t._v(" "),s("h2",{attrs:{id:"_1-你对mvvm如何理解？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-你对mvvm如何理解？"}},[t._v("#")]),t._v(" 1.你对MVVM如何理解？")]),t._v(" "),s("p",[t._v("MVVM模式是什么？")]),t._v(" "),s("p",[t._v("MVVM模式，顾名思义即Model-View-ViewModel模式。它萌芽于05年微软退出的基于windows的用户框架WPF，前端最早的MVVM框架 knockout在 10年发布。")]),t._v(" "),s("p",[t._v("Model层：对应数据层的域模型，它主要做域模型的同步。通过Ajax/fetch等API完成客户端和服务端业务Model的同步，在层级关系里，它主要用于抽象出ViewModel中的视图的Model。")]),t._v(" "),s("p",[t._v("View层：作为视图模板存在，在MVVM里，整个View是一个动态模板。除了定义结构、布局外，它展示的是ViewModel层的数据和状态。View层不负责处理状态，View层做的是 数据绑定的声明、指令的声明、事件绑定的声明。")]),t._v(" "),s("p",[t._v("ViewModel层：把View需要的层数据暴露，并对View层的数据绑定声明、指令声明、时间绑定声明、负责、也就是处理View层的具体业务逻辑。ViewModel底层会做好绑定属性的监听。当ViewModel中数据变化，View层会得到更新；而当View中声明了数据的双向绑定(通常是表单元素)，框架也会监听View层（表单）值的变化。一旦值变化，View层绑定的ViewModel中的数据也会得到自动更新。")]),t._v(" "),s("p",[s("img",{attrs:{src:e(348),alt:"avatar"}})]),t._v(" "),s("p",[t._v("MVVM的优缺点：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("优点:")]),t._v(" "),s("p",[t._v("1.分离视图（View）和模型（Model），降低代码耦合，提高视图或者逻辑的重用性：比如视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定不同的'View'上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑")]),t._v(" "),s("p",[t._v("2.提高测试性：ViewModel的存在可以帮助开发者更好地编写测试代码")]),t._v(" "),s("p",[t._v("3.自动更新dom；利用双向绑定，数据更新后视图自动更新，让开发者从满所的手动dom中解放。")])]),t._v(" "),s("li",[s("p",[t._v("缺点：")]),t._v(" "),s("p",[t._v("1.Bug很难被调试，因为使用双向绑定的模式，当你看到界面异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题，数据绑定使一个位置的Bug被快速传递到别的位置，要定位原始出问题的地方变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模板当中的，这些内容是没有办法打断点debug的。")]),t._v(" "),s("p",[t._v("2.一个大的模块中的model也会很大，虽然使用方便了也很容易保证了数据的一致性，当时长期持有，不释放内存就会造成了花费更多的内存。")]),t._v(" "),s("p",[t._v("3.对于大型的视图应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高。")])])]),t._v(" "),s("h2",{attrs:{id:"_2-你对vue生命周期的理解？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-你对vue生命周期的理解？"}},[t._v("#")]),t._v(" 2.你对Vue生命周期的理解？")]),t._v(" "),s("p",[t._v("生命周期是什么")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom->渲染、更新->渲染、卸载等一系列过程，我们称这是Vue的生命周期。")]),t._v(" "),s("p",[t._v("各个生命周期的作用")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("生命周期")]),t._v(" "),s("th",[t._v("描述")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("beforeCreate")]),t._v(" "),s("td",[t._v("组件实例 被创建之初，组件的属性生效之前")])]),t._v(" "),s("tr",[s("td",[t._v("created")]),t._v(" "),s("td",[t._v("组件实例已经完全创建，属性也绑定，但真实dom还没生成，$el还不可用")])]),t._v(" "),s("tr",[s("td",[t._v("beforeMount")]),t._v(" "),s("td",[t._v("在挂载开始之前被调用：相关的render函数首次被调用")])]),t._v(" "),s("tr",[s("td",[t._v("mounted")]),t._v(" "),s("td",[t._v("el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子")])]),t._v(" "),s("tr",[s("td",[t._v("beforeUpdate")]),t._v(" "),s("td",[t._v("组件数据更新之前调用，发生在虚拟DOM打补丁之前")])]),t._v(" "),s("tr",[s("td",[t._v("update")]),t._v(" "),s("td",[t._v("组件数据更新之后")])]),t._v(" "),s("tr",[s("td",[t._v("activited")]),t._v(" "),s("td",[t._v("keep-alive专属，组件被激活时调用")])]),t._v(" "),s("tr",[s("td",[t._v("deadctivated")]),t._v(" "),s("td",[t._v("keep-alive专属，组件被销毁时调用")])]),t._v(" "),s("tr",[s("td",[t._v("beforeDestory")]),t._v(" "),s("td",[t._v("组件销毁前调用")])]),t._v(" "),s("tr",[s("td",[t._v("destoryed")]),t._v(" "),s("td",[t._v("组件销毁后调用")])])])]),t._v(" "),s("p",[t._v("生命周期示意图")]),t._v(" "),s("p",[s("img",{attrs:{src:e(349),alt:"avatar"}})])])]),t._v(" "),s("h3",{attrs:{id:"异步请求合适在哪个生命周期调用？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异步请求合适在哪个生命周期调用？"}},[t._v("#")]),t._v(" 异步请求合适在哪个生命周期调用？")]),t._v(" "),s("p",[t._v("官方实例的异步请求是在 mounted生命周期中调用的，而实际上也可以在created生命周期中调用。")]),t._v(" "),s("h2",{attrs:{id:"_3-vue如何通信？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-vue如何通信？"}},[t._v("#")]),t._v(" 3.Vue如何通信？")]),t._v(" "),s("ol",[s("li",[t._v("props/$emit+v-on: 通过props将数据自上而下传递，而通过$emit和v-on来向上传递信息。")]),t._v(" "),s("li",[t._v("EventBus:通过EventBus进行信息的发布与订阅")]),t._v(" "),s("li",[t._v("vuex：是全局数据管理库，可以通过vuex管理全局的数据流")]),t._v(" "),s("li",[t._v("$attr/$listeners:Vue2.4中加入的$attr/$listeners可以进行跨级的组件通信")]),t._v(" "),s("li",[t._v("provide/inject: 以 允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效，这成为了跨组件通信的基础")])]),t._v(" "),s("h2",{attrs:{id:"_4-computed和watch有什么区别？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-computed和watch有什么区别？"}},[t._v("#")]),t._v(" 4.computed和watch有什么区别？")]),t._v(" "),s("p",[t._v("computed:")]),t._v(" "),s("ol",[s("li",[t._v("computed 是计算属性，也就是计算值，它更多用于计算值的场景")]),t._v(" "),s("li",[t._v("computed 具有缓存性，computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值才会重新调用对应的getter来计算")]),t._v(" "),s("li",[t._v("computed 试用于计算比较消耗性能的计算场景")])]),t._v(" "),s("p",[t._v("wach:")]),t._v(" "),s("ol",[s("li",[t._v("更多的是 [观察] 的作用，类似于某些数据的监听毁掉，用于观察 props  $emit 或者本组件的值，当数据变化时来执行回调进行后续操作")]),t._v(" "),s("li",[t._v("无缓存性，页面重新渲染时值不变化也会执行")])]),t._v(" "),s("p",[t._v("小结：")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("当我们要进行数据计算，而且依赖于其他数据，那么把这个数据设计为computed")])]),t._v(" "),s("li",[s("p",[t._v("如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化")])])]),t._v(" "),s("h2",{attrs:{id:"_5-vue是如何实现双向绑定的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-vue是如何实现双向绑定的"}},[t._v("#")]),t._v(" 5.Vue是如何实现双向绑定的?")]),t._v(" "),s("p",[t._v("利用 Obejct.defineProperty 劫持对象的访问器，在属性值发生变化时我们可以获取变化，然后根据变化进行后续响应，在Vue3.0中通过Proxy代理对象进行类似的操作。")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("//这是将要被劫持的对象\n\nconst data "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tname:"),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("''")]),t._v(",\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" say"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tif"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("name "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'古天乐'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\tconsole.log"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'给大家推荐一款超好玩的游戏'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("name "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'渣渣辉'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\tconsole.log"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'戏我演过很多，可游戏我只玩贪玩蓝月'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\tconsole.log"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'来做我的兄弟'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n//遍历对象，对其属性值进行劫持\nObject.keys"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("data"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(".forEach"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("function"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("))")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tObject.defineProperty"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("data,key,"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\tenumerable:true,\n\t\tconfiguerable:true,\n\t\tget:"),s("span",{pre:!0,attrs:{class:"token function-name function"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t\tconsole.log"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'get'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(",\n\t\tset:function"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("newVal"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t\tconsole.log"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'大家好，我系"),s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("${newVal}")]),t._v("'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t\t\tsay"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("newVal"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(",\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\ndata.name "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'渣渣辉'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n//大家好，我系渣渣辉\n//戏我演过很多，可游戏我只玩贪玩蓝月\n\n")])])]),s("h3",{attrs:{id:"proxy与object-defineproperty的优劣势-追问"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#proxy与object-defineproperty的优劣势-追问"}},[t._v("#")]),t._v(" Proxy与Object.defineProperty的优劣势(追问)")]),t._v(" "),s("p",[t._v("Proxy的优势如下："),s("br"),t._v("\nProxy可以直接监听对象而非属性"),s("br"),t._v("\nProxy可以直接监听数组的变化"),s("br"),t._v("\nproxy有多达13种拦截方法，不限于apply、ownKeys、deleteProperty、has等等是 Object.defineProperty 不具备的"),s("br"),t._v("\nProxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利"),s("br")]),t._v(" "),s("p",[t._v("Obejct.defineProperty的优势如下：\n兼容性好，支持IE9")]),t._v(" "),s("h2",{attrs:{id:"_6-你是如何理解vue的响应式系统的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-你是如何理解vue的响应式系统的"}},[t._v("#")]),t._v(" 6.你是如何理解Vue的响应式系统的?")]),t._v(" "),s("p",[s("img",{attrs:{src:e(350),alt:"avatar"}})]),t._v(" "),s("p",[t._v("响应式系统简述:"),s("br"),t._v("\n任何一个 Vue Component 都有一个与之对应的Watcher实例。"),s("br"),t._v("\nVue的data上的属性会被添加getter和setter属性。"),s("br"),t._v("\n当Vue Component render函数被执行的时候，data上会被触碰(touch)，即被读，getter方法会被调用，此时Vue会去记录此Vue Component所以来的所有data。（这一过程被称为依赖收集）"),s("br"),t._v("\ndata被改动时(主要是用户操作)，即被写，setter方法会被调用，此时Vue会去通知所有依赖于此data的组件去调用他们的render函数进行更新。"),s("br")]),t._v(" "),s("h3",{attrs:{id:"既然vue通过数据劫持可以精准探测数据变化，为什么还需要虚拟dom进行diff检测差异"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#既然vue通过数据劫持可以精准探测数据变化，为什么还需要虚拟dom进行diff检测差异"}},[t._v("#")]),t._v(" 既然Vue通过数据劫持可以精准探测数据变化，为什么还需要虚拟DOM进行diff检测差异?")]),t._v(" "),s("p",[t._v("考点: Vue的变化侦测原理"),s("br")]),t._v(" "),s("p",[t._v("前置知识：依赖收集、虚拟DOM、响应式系统"),s("br")]),t._v(" "),s("p",[t._v("现代前段框架有两种方式侦测变化，一种是pull一种是push"),s("br")]),t._v(" "),s("p",[t._v("pull：其代表为Rect，我们可以回忆一下React是如何侦测到变化的，我们通常会用 setState API 显示更新，然后React会进行一层层的Virtual Dom Diff操作找出差异，然Patch到Dom上，React从一开始就不知道到底是哪发生了变化，只是知道[有变化了]，然后进行比较暴力的Diff操作查找 [哪发生变化了]，另外一个代表就是Angular 的脏检查操作。"),s("br")]),t._v(" "),s("p",[t._v("push:Vue的响应式系统则是push的代表，当Vue程序初始化的时候就会对数据data进行依赖的收集，一旦数据发生变化，响应式系统就会立刻得知，因此Vue是一开始就知道是[在哪发生变化了]，但是这又会产生一个问题，如果你熟悉Vue的响应式系统就知道，通常一个绑定一个数据就需要一个Watcher，一旦我们的绑定细粒度过高就会产生大量的Watcher，这回带来内存以及依赖追逐的开销，而细粒度过地回无法精准侦测变化，因此Vue的设计师选择中的呢个细粒度的方案。在组件级别进行push侦测的方式，也就是那套响应式系统，通常我们会第一时间侦测到发生变化的组件，然后在组件内部进行Virtual Dom Diff获取更加具体的差异，而Virtual Dom Diff 则是pull操作，Vue是push+pull结合的方式进行变化侦测的。")]),t._v(" "),s("h2",{attrs:{id:"_7-vue为什么没有类似于react中shouldcomponentupdate的生命周期？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-vue为什么没有类似于react中shouldcomponentupdate的生命周期？"}},[t._v("#")]),t._v(" 7.Vue为什么没有类似于React中shouldComponentUpdate的生命周期？")]),t._v(" "),s("p",[t._v("考点：Vue的变化侦测原理"),s("br")]),t._v(" "),s("p",[t._v("前置知识：依赖收集、虚拟DOM、响应式系统"),s("br")]),t._v(" "),s("p",[t._v("React是pull的方式侦测变化，当React知道发生变化后，会使用Virtual Dom进行差异检测，但是很多组件实际上是肯定不会发生变化的，这个时候需要用shouldComponentUpdate进行手动操作来减少diff，从而提高程序整体的性能"),s("br")]),t._v(" "),s("p",[t._v("Vue是pull+push的方式侦测变化的，在一开始就知道那个组件发生了变化，因此在push的阶段并不需要手动控制diff，而组件内部采用的diff方式实际上是可以引入类似于shouldComponentUpdate相关生命周期的，但是通常合理大小的组件不会有过量的diff，手动优化的价值有限，一次目前Vue并没有考虑引入shouldComponentUpdate这种手动优化的生命周期。"),s("br")]),t._v(" "),s("h2",{attrs:{id:"_8-vue中的key到底有什么作用？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-vue中的key到底有什么作用？"}},[t._v("#")]),t._v(" 8.Vue中的key到底有什么作用？")]),t._v(" "),s("p",[t._v("key是为Vue中的vnode标记的唯一id，通过这个key，我们的diff操作可以更准确，更快速"),s("br")]),t._v(" "),s("p",[t._v("diff算法的过程中，先进行新旧节点的首尾交叉对比，当无法匹配的时候会用新节点key与旧节点进行比对，然后找出差异。"),s("br")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("diff程可以概括为：oldCh和newCh个有两个头尾的变量Startldx和Enddx，他们的2个变量互相比较，一共有4种比较方式。如果4种比较陡没匹配，如果设置了key，就会用key进行比较，在比较过程中，变量会让中间靠，一旦startidx > Endldx表明oldCh和newCh至少有一个以及遍历完了，就会结束比较，这四种比较方式就是首、尾、旧尾新头，旧头新尾。\n\n")])])]),s("br"),t._v("\n准确：如果不加key，那么vue会选择复用节点（Vue的就地更新策略），导致之前节点的状态被保留下来，会产生一系列的bug。"),s("br"),t._v(" "),s("p",[t._v("快速：key的唯一性可以被Map树结构充分利用，相比于遍历查找的时间复杂度O(n),Map的时间复杂度仅仅为O(1)"),s("br")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" createKeyToOldIdx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("chilren,beginIdx,endIdx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("let")]),t._v(" i,key\n\tconst map "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" beginIdx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" endIdx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" ++i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\tkey "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" children"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(".key\n\t\tif"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("isDef"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("))")]),t._v(" map"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" i\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\trerturn map\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n\n")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);