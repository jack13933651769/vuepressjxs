<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue面试题 | 蒋鲜生の前端学习笔记</title>
    <meta name="generator" content="VuePress 1.5.1">
    
    <meta name="description" content="这是一个总结前端知识的网站鸭！">
    <link rel="preload" href="/iview/notes/assets/css/0.styles.c0acf2c6.css" as="style"><link rel="preload" href="/iview/notes/assets/js/app.d36e3637.js" as="script"><link rel="preload" href="/iview/notes/assets/js/2.13abcbbe.js" as="script"><link rel="preload" href="/iview/notes/assets/js/3.3fcb36f2.js" as="script"><link rel="prefetch" href="/iview/notes/assets/js/10.9f2f7e6d.js"><link rel="prefetch" href="/iview/notes/assets/js/11.c96a2c5c.js"><link rel="prefetch" href="/iview/notes/assets/js/4.4445d2f2.js"><link rel="prefetch" href="/iview/notes/assets/js/5.7254270b.js"><link rel="prefetch" href="/iview/notes/assets/js/6.3e290fbb.js"><link rel="prefetch" href="/iview/notes/assets/js/7.4f6c22d7.js"><link rel="prefetch" href="/iview/notes/assets/js/8.f69189d4.js"><link rel="prefetch" href="/iview/notes/assets/js/9.83f7dbc1.js">
    <link rel="stylesheet" href="/iview/notes/assets/css/0.styles.c0acf2c6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/iview/notes/" class="home-link router-link-active"><!----> <span class="site-name">蒋鲜生の前端学习笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/iview/notes/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/iview/notes/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="https://google.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  External
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/iview/notes/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/iview/notes/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="https://google.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  External
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前言</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/iview/notes/" aria-current="page" class="sidebar-link">关于我</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Js基础知识</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React基础知识</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>前端常见面试题</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/iview/notes/面试题/跨域的几种方式.html" class="sidebar-link">跨域问题</a></li><li><a href="/iview/notes/面试题/css水平垂直居中的几种方式.html" class="sidebar-link">css水平垂直居中的几种方式</a></li><li><a href="/iview/notes/面试题/vue面试题.html" class="active sidebar-link">Vue面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/iview/notes/面试题/vue面试题.html#_1-你对mvvm如何理解？" class="sidebar-link">1.你对MVVM如何理解？</a></li><li class="sidebar-sub-header"><a href="/iview/notes/面试题/vue面试题.html#_2-你对vue生命周期的理解？" class="sidebar-link">2.你对Vue生命周期的理解？</a></li><li class="sidebar-sub-header"><a href="/iview/notes/面试题/vue面试题.html#_3-vue如何通信？" class="sidebar-link">3.Vue如何通信？</a></li><li class="sidebar-sub-header"><a href="/iview/notes/面试题/vue面试题.html#_4-computed和watch有什么区别？" class="sidebar-link">4.computed和watch有什么区别？</a></li><li class="sidebar-sub-header"><a href="/iview/notes/面试题/vue面试题.html#_5-vue是如何实现双向绑定的" class="sidebar-link">5.Vue是如何实现双向绑定的?</a></li><li class="sidebar-sub-header"><a href="/iview/notes/面试题/vue面试题.html#_6-你是如何理解vue的响应式系统的" class="sidebar-link">6.你是如何理解Vue的响应式系统的?</a></li><li class="sidebar-sub-header"><a href="/iview/notes/面试题/vue面试题.html#_7-vue为什么没有类似于react中shouldcomponentupdate的生命周期？" class="sidebar-link">7.Vue为什么没有类似于React中shouldComponentUpdate的生命周期？</a></li><li class="sidebar-sub-header"><a href="/iview/notes/面试题/vue面试题.html#_8-vue中的key到底有什么作用？" class="sidebar-link">8.Vue中的key到底有什么作用？</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue面试题"><a href="#vue面试题" class="header-anchor">#</a> Vue面试题</h1> <h2 id="_1-你对mvvm如何理解？"><a href="#_1-你对mvvm如何理解？" class="header-anchor">#</a> 1.你对MVVM如何理解？</h2> <p>MVVM模式是什么？</p> <p>MVVM模式，顾名思义即Model-View-ViewModel模式。它萌芽于05年微软退出的基于windows的用户框架WPF，前端最早的MVVM框架 knockout在 10年发布。</p> <p>Model层：对应数据层的域模型，它主要做域模型的同步。通过Ajax/fetch等API完成客户端和服务端业务Model的同步，在层级关系里，它主要用于抽象出ViewModel中的视图的Model。</p> <p>View层：作为视图模板存在，在MVVM里，整个View是一个动态模板。除了定义结构、布局外，它展示的是ViewModel层的数据和状态。View层不负责处理状态，View层做的是 数据绑定的声明、指令的声明、事件绑定的声明。</p> <p>ViewModel层：把View需要的层数据暴露，并对View层的数据绑定声明、指令声明、时间绑定声明、负责、也就是处理View层的具体业务逻辑。ViewModel底层会做好绑定属性的监听。当ViewModel中数据变化，View层会得到更新；而当View中声明了数据的双向绑定(通常是表单元素)，框架也会监听View层（表单）值的变化。一旦值变化，View层绑定的ViewModel中的数据也会得到自动更新。</p> <p><img src="/iview/notes/assets/img/vue.42de5b0b.jpg" alt="avatar"></p> <p>MVVM的优缺点：</p> <ul><li><p>优点:</p> <p>1.分离视图（View）和模型（Model），降低代码耦合，提高视图或者逻辑的重用性：比如视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定不同的'View'上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑</p> <p>2.提高测试性：ViewModel的存在可以帮助开发者更好地编写测试代码</p> <p>3.自动更新dom；利用双向绑定，数据更新后视图自动更新，让开发者从满所的手动dom中解放。</p></li> <li><p>缺点：</p> <p>1.Bug很难被调试，因为使用双向绑定的模式，当你看到界面异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题，数据绑定使一个位置的Bug被快速传递到别的位置，要定位原始出问题的地方变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模板当中的，这些内容是没有办法打断点debug的。</p> <p>2.一个大的模块中的model也会很大，虽然使用方便了也很容易保证了数据的一致性，当时长期持有，不释放内存就会造成了花费更多的内存。</p> <p>3.对于大型的视图应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高。</p></li></ul> <h2 id="_2-你对vue生命周期的理解？"><a href="#_2-你对vue生命周期的理解？" class="header-anchor">#</a> 2.你对Vue生命周期的理解？</h2> <p>生命周期是什么</p> <ul><li><p>Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom-&gt;渲染、更新-&gt;渲染、卸载等一系列过程，我们称这是Vue的生命周期。</p> <p>各个生命周期的作用</p> <table><thead><tr><th>生命周期</th> <th>描述</th></tr></thead> <tbody><tr><td>beforeCreate</td> <td>组件实例 被创建之初，组件的属性生效之前</td></tr> <tr><td>created</td> <td>组件实例已经完全创建，属性也绑定，但真实dom还没生成，$el还不可用</td></tr> <tr><td>beforeMount</td> <td>在挂载开始之前被调用：相关的render函数首次被调用</td></tr> <tr><td>mounted</td> <td>el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子</td></tr> <tr><td>beforeUpdate</td> <td>组件数据更新之前调用，发生在虚拟DOM打补丁之前</td></tr> <tr><td>update</td> <td>组件数据更新之后</td></tr> <tr><td>activited</td> <td>keep-alive专属，组件被激活时调用</td></tr> <tr><td>deadctivated</td> <td>keep-alive专属，组件被销毁时调用</td></tr> <tr><td>beforeDestory</td> <td>组件销毁前调用</td></tr> <tr><td>destoryed</td> <td>组件销毁后调用</td></tr></tbody></table> <p>生命周期示意图</p> <p><img src="/iview/notes/assets/img/vue1.612e2a12.png" alt="avatar"></p></li></ul> <h3 id="异步请求合适在哪个生命周期调用？"><a href="#异步请求合适在哪个生命周期调用？" class="header-anchor">#</a> 异步请求合适在哪个生命周期调用？</h3> <p>官方实例的异步请求是在 mounted生命周期中调用的，而实际上也可以在created生命周期中调用。</p> <h2 id="_3-vue如何通信？"><a href="#_3-vue如何通信？" class="header-anchor">#</a> 3.Vue如何通信？</h2> <ol><li>props/$emit+v-on: 通过props将数据自上而下传递，而通过$emit和v-on来向上传递信息。</li> <li>EventBus:通过EventBus进行信息的发布与订阅</li> <li>vuex：是全局数据管理库，可以通过vuex管理全局的数据流</li> <li>$attr/$listeners:Vue2.4中加入的$attr/$listeners可以进行跨级的组件通信</li> <li>provide/inject: 以 允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效，这成为了跨组件通信的基础</li></ol> <h2 id="_4-computed和watch有什么区别？"><a href="#_4-computed和watch有什么区别？" class="header-anchor">#</a> 4.computed和watch有什么区别？</h2> <p>computed:</p> <ol><li>computed 是计算属性，也就是计算值，它更多用于计算值的场景</li> <li>computed 具有缓存性，computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值才会重新调用对应的getter来计算</li> <li>computed 试用于计算比较消耗性能的计算场景</li></ol> <p>wach:</p> <ol><li>更多的是 [观察] 的作用，类似于某些数据的监听毁掉，用于观察 props  $emit 或者本组件的值，当数据变化时来执行回调进行后续操作</li> <li>无缓存性，页面重新渲染时值不变化也会执行</li></ol> <p>小结：</p> <ol><li><p>当我们要进行数据计算，而且依赖于其他数据，那么把这个数据设计为computed</p></li> <li><p>如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化</p></li></ol> <h2 id="_5-vue是如何实现双向绑定的"><a href="#_5-vue是如何实现双向绑定的" class="header-anchor">#</a> 5.Vue是如何实现双向绑定的?</h2> <p>利用 Obejct.defineProperty 劫持对象的访问器，在属性值发生变化时我们可以获取变化，然后根据变化进行后续响应，在Vue3.0中通过Proxy代理对象进行类似的操作。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>//这是将要被劫持的对象

const data <span class="token operator">=</span> <span class="token punctuation">{</span>
	name:<span class="token string">''</span>,
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> say<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>
	if<span class="token punctuation">(</span>name <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">'古天乐'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		console.log<span class="token punctuation">(</span><span class="token string">'给大家推荐一款超好玩的游戏'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">'渣渣辉'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		console.log<span class="token punctuation">(</span><span class="token string">'戏我演过很多，可游戏我只玩贪玩蓝月'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		console.log<span class="token punctuation">(</span><span class="token string">'来做我的兄弟'</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
//遍历对象，对其属性值进行劫持
Object.keys<span class="token punctuation">(</span>data<span class="token punctuation">)</span>.forEach<span class="token punctuation">(</span>function<span class="token punctuation">(</span>key<span class="token punctuation">))</span> <span class="token punctuation">{</span>
	Object.defineProperty<span class="token punctuation">(</span>data,key,<span class="token punctuation">{</span>
		enumerable:true,
		configuerable:true,
		get:<span class="token function-name function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			console.log<span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>,
		set:function<span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			console.log<span class="token punctuation">(</span><span class="token string">'大家好，我系<span class="token variable">${newVal}</span>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			say<span class="token punctuation">(</span>newVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>,
	<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

data.name <span class="token operator">=</span> <span class="token string">'渣渣辉'</span><span class="token punctuation">;</span>
//大家好，我系渣渣辉
//戏我演过很多，可游戏我只玩贪玩蓝月

</code></pre></div><h3 id="proxy与object-defineproperty的优劣势-追问"><a href="#proxy与object-defineproperty的优劣势-追问" class="header-anchor">#</a> Proxy与Object.defineProperty的优劣势(追问)</h3> <p>Proxy的优势如下：<br>
Proxy可以直接监听对象而非属性<br>
Proxy可以直接监听数组的变化<br>
proxy有多达13种拦截方法，不限于apply、ownKeys、deleteProperty、has等等是 Object.defineProperty 不具备的<br>
Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利<br></p> <p>Obejct.defineProperty的优势如下：
兼容性好，支持IE9</p> <h2 id="_6-你是如何理解vue的响应式系统的"><a href="#_6-你是如何理解vue的响应式系统的" class="header-anchor">#</a> 6.你是如何理解Vue的响应式系统的?</h2> <p><img src="/iview/notes/assets/img/vue2.6cb4375c.jpg" alt="avatar"></p> <p>响应式系统简述:<br>
任何一个 Vue Component 都有一个与之对应的Watcher实例。<br>
Vue的data上的属性会被添加getter和setter属性。<br>
当Vue Component render函数被执行的时候，data上会被触碰(touch)，即被读，getter方法会被调用，此时Vue会去记录此Vue Component所以来的所有data。（这一过程被称为依赖收集）<br>
data被改动时(主要是用户操作)，即被写，setter方法会被调用，此时Vue会去通知所有依赖于此data的组件去调用他们的render函数进行更新。<br></p> <h3 id="既然vue通过数据劫持可以精准探测数据变化，为什么还需要虚拟dom进行diff检测差异"><a href="#既然vue通过数据劫持可以精准探测数据变化，为什么还需要虚拟dom进行diff检测差异" class="header-anchor">#</a> 既然Vue通过数据劫持可以精准探测数据变化，为什么还需要虚拟DOM进行diff检测差异?</h3> <p>考点: Vue的变化侦测原理<br></p> <p>前置知识：依赖收集、虚拟DOM、响应式系统<br></p> <p>现代前段框架有两种方式侦测变化，一种是pull一种是push<br></p> <p>pull：其代表为Rect，我们可以回忆一下React是如何侦测到变化的，我们通常会用 setState API 显示更新，然后React会进行一层层的Virtual Dom Diff操作找出差异，然Patch到Dom上，React从一开始就不知道到底是哪发生了变化，只是知道[有变化了]，然后进行比较暴力的Diff操作查找 [哪发生变化了]，另外一个代表就是Angular 的脏检查操作。<br></p> <p>push:Vue的响应式系统则是push的代表，当Vue程序初始化的时候就会对数据data进行依赖的收集，一旦数据发生变化，响应式系统就会立刻得知，因此Vue是一开始就知道是[在哪发生变化了]，但是这又会产生一个问题，如果你熟悉Vue的响应式系统就知道，通常一个绑定一个数据就需要一个Watcher，一旦我们的绑定细粒度过高就会产生大量的Watcher，这回带来内存以及依赖追逐的开销，而细粒度过地回无法精准侦测变化，因此Vue的设计师选择中的呢个细粒度的方案。在组件级别进行push侦测的方式，也就是那套响应式系统，通常我们会第一时间侦测到发生变化的组件，然后在组件内部进行Virtual Dom Diff获取更加具体的差异，而Virtual Dom Diff 则是pull操作，Vue是push+pull结合的方式进行变化侦测的。</p> <h2 id="_7-vue为什么没有类似于react中shouldcomponentupdate的生命周期？"><a href="#_7-vue为什么没有类似于react中shouldcomponentupdate的生命周期？" class="header-anchor">#</a> 7.Vue为什么没有类似于React中shouldComponentUpdate的生命周期？</h2> <p>考点：Vue的变化侦测原理<br></p> <p>前置知识：依赖收集、虚拟DOM、响应式系统<br></p> <p>React是pull的方式侦测变化，当React知道发生变化后，会使用Virtual Dom进行差异检测，但是很多组件实际上是肯定不会发生变化的，这个时候需要用shouldComponentUpdate进行手动操作来减少diff，从而提高程序整体的性能<br></p> <p>Vue是pull+push的方式侦测变化的，在一开始就知道那个组件发生了变化，因此在push的阶段并不需要手动控制diff，而组件内部采用的diff方式实际上是可以引入类似于shouldComponentUpdate相关生命周期的，但是通常合理大小的组件不会有过量的diff，手动优化的价值有限，一次目前Vue并没有考虑引入shouldComponentUpdate这种手动优化的生命周期。<br></p> <h2 id="_8-vue中的key到底有什么作用？"><a href="#_8-vue中的key到底有什么作用？" class="header-anchor">#</a> 8.Vue中的key到底有什么作用？</h2> <p>key是为Vue中的vnode标记的唯一id，通过这个key，我们的diff操作可以更准确，更快速<br></p> <p>diff算法的过程中，先进行新旧节点的首尾交叉对比，当无法匹配的时候会用新节点key与旧节点进行比对，然后找出差异。<br></p> <div class="language- extra-class"><pre class="language-text"><code>diff程可以概括为：oldCh和newCh个有两个头尾的变量Startldx和Enddx，他们的2个变量互相比较，一共有4种比较方式。如果4种比较陡没匹配，如果设置了key，就会用key进行比较，在比较过程中，变量会让中间靠，一旦startidx &gt; Endldx表明oldCh和newCh至少有一个以及遍历完了，就会结束比较，这四种比较方式就是首、尾、旧尾新头，旧头新尾。

</code></pre></div><br>
准确：如果不加key，那么vue会选择复用节点（Vue的就地更新策略），导致之前节点的状态被保留下来，会产生一系列的bug。<br> <p>快速：key的唯一性可以被Map树结构充分利用，相比于遍历查找的时间复杂度O(n),Map的时间复杂度仅仅为O(1)<br></p> <div class="language-bash extra-class"><pre class="language-bash"><code>
<span class="token keyword">function</span> createKeyToOldIdx<span class="token punctuation">(</span>chilren,beginIdx,endIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token builtin class-name">let</span> i,key
	const map <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> beginIdx<span class="token punctuation">;</span> i <span class="token operator">&lt;</span><span class="token operator">=</span> endIdx<span class="token punctuation">;</span> ++i<span class="token punctuation">)</span><span class="token punctuation">{</span>
		key <span class="token operator">=</span> children<span class="token punctuation">[</span>i<span class="token punctuation">]</span>.key
		if<span class="token punctuation">(</span>isDef<span class="token punctuation">(</span>key<span class="token punctuation">))</span> map<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> i
	<span class="token punctuation">}</span>
	rerturn map
<span class="token punctuation">}</span>


</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/iview/notes/面试题/css水平垂直居中的几种方式.html" class="prev">
        css水平垂直居中的几种方式
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/iview/notes/assets/js/app.d36e3637.js" defer></script><script src="/iview/notes/assets/js/2.13abcbbe.js" defer></script><script src="/iview/notes/assets/js/3.3fcb36f2.js" defer></script>
  </body>
</html>
