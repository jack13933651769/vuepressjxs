# 跨域问题

## 什么是跨域
- 跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。
- 广域的跨域：
```bash
1. 资源跳转： A链接、重定向、表单提交
2. 资源嵌入： <link>、<script>、<img>、<frame>等dom标签，还有样式中background:url()、@font-face()等文件外链
3. 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等
```
- 其实我们说的都是狭义的跨域问题，及浏览器同源策略（因为安全问题），是由浏览器同源策略限制的一类请求场景。
## 什么是同源策略
- 同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也是最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS,CSFR等攻击。所谓同源指 “<font color=red size=4 >协议+域名+端口</font>”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。

- 同源策略限制以下几种行为：
```bash
1. Cookie、LocalStorage 和 IndexDB 无法读取
2. DOM 和 Js对象无法获得
3. AJAX 请求不能发送
```
### 常见的跨域场景

<table>
    <tr>
        <th>URL</th>
        <th>说明</th>
		<th >是否允许通信</th>
    </tr>
    <tr>
        <td>http://www.jxshouse.club/a.js</td>
        <td rowspan="3">  同一域名，不同文件或路径   </td>
		<td rowspan="3">允许</td>
    </tr>
    <tr>
        <td>http://www.jxshouse.club/b.js</td>
    </tr>
    <tr>
        <td>http://www.jxshouse.club/lab/c.js</td>
    </tr>
	<tr>
        <td>http://www.jxshouse.club:8000/a.js</td>
        <td rowspan="2">   同一域名，不同端口     </td>
		<td rowspan="2">不允许</td>
    </tr>
    <tr>
        <td>http://www.jxshouse.club/b.js</td>
    </tr>
	<tr>
        <td>http://www.jxshouse.club/a.js</td>
        <td rowspan="2">   同一域名，不同协议    </td>
		<td rowspan="2">不允许</td>
    </tr>
    <tr>
        <td>https://www.jxshouse.club/b.js</td>
    </tr>
	<tr>
        <td>http://www.jxshouse.club/a.js</td>
        <td rowspan="2">  域名和域名对应相同ip    </td>
		<td rowspan="2">不允许</td>
    </tr>
    <tr>
        <td>http://192.168.4.12/b.js </td>
    </tr>
	    <tr>
        <td>http://www.jxshouse.club/a.js</td>
        <td rowspan="3">  主域相同，子域不同  </td>
		<td rowspan="3">允许</td>
    </tr>
    <tr>
        <td>http://x.jxshouse.club/b.js </td>
    </tr>
    <tr>
        <td>http://jxshouse.club/c.js</td>
    </tr>
	<tr>
        <td>http://www.jxshouse1.club/a.js</td>
        <td rowspan="2">    不同域名      </td>
		<td rowspan="2">不允许</td>
    </tr>
    <tr>
        <td>http://192.168.4.12/b.js </td>
    </tr>
</table>

## 跨域解决方案
```bash
1、 通过jsonp跨域
2、 跨域资源共享（CORS）
3、 nodejs中间件代理跨域
4、 nginx代理跨域 
5、 postMessage跨域 
6、 WebSocket协议跨域
7、 location.hash + iframe 
8、 document.domain + iframe跨域
9、 window.name + iframe跨域
```

#### 1、 通过jsonp跨域

通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。

1.原生js实现
```bash
	<script>
		let script = document.createElement('script');
		script.type = 'text/javascript';
		//传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
		script.src='http://www.jxshouse.club:8080/login?user=admin&callback=handleCallback';
		//回调执行函数
		function handleCallback(res){
			alert(JSON.stringify(res));
		}
	</script>
```
服务端返回如下（返回时即执行全局函数）
```bash
	handleCallback({'status':true,'user':'admin'})
```
后端node.js 代码示例：

```bash
	let querystring = require('querystring');
	let http = require('http');
	let server = http.createServer();

	server.on('request',function(req,res){
		var params = qs.parse(req.url.split('?')[1]);
		var fn = params.callback;
		//jsonp返回设置
		res.writeHead(200,{'Content-Type':'text/javascript'});
		res.write(fn+'('+JSON.stringify(params)+')');
		res.end();
	})
server.listen('8080');
```

jsonp缺点：只能实现get一种请求。

#### 2、  跨域资源共享（CORS）

普通跨域请求：只服务端设置<font color=red size=4 > 响应头 Access-Control-Allow-Origin</font>即可，前端无须设置，若要带cookie请求：前后端都需要设置。

需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：三、nginx反向代理中设置proxy_cookie_domain 和 四、NodeJs中间件代理中cookieDomainRewrite参数的设置。

目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS)，CORS也已经成为主流的跨域解决方案。

1.前端设置

```bash

// 前端设置是否带cookie
xhr.withCredentials = true;

```
实例代码：

原生
```bash
let xhr = new XMLHttpRequest(); //IE8/9需用windos.XDomainRequest兼容
//前端设置是否带cookie
xhr.withCredentials = true;

xhr.open('post','http://www.jxshouse.club:8080/login',true);
xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded');
xhr.send('user=admin');

xhr.onreadystatechange = function(){
	if(xhr.readyState ==4 &&xhr.status ==200){
		alert(xhr.responseText);
	}
}
```
axios
```bash 
axios.defaults.withCredentials = true
```

2.服务器设置:

若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没成功。

java

```bash 
/*
 * 导入包：import javax.servlet.http.HttpServletResponse;
 * 接口参数中定义：HttpServletResponse response
 */

// 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加'/'
response.setHeader("Access-Control-Allow-Origin", "http://www.jxshouse1.club"); 

// 允许前端带认证cookie：启用此项后，上面的域名不能为'*'，必须指定具体的域名，否则浏览器会提示
response.setHeader("Access-Control-Allow-Credentials", "true"); 

// 提示OPTIONS预检时，后端需要设置的两个常用自定义头
response.setHeader("Access-Control-Allow-Headers", "Content-Type,X-Requested-With");
```

Nodejs

```bash 
var http = require('http');
var server = http.createServer();
var qs = require('querystring');

server.on('request', function(req, res) {
    var postData = '';

    // 数据块接收中
    req.addListener('data', function(chunk) {
        postData += chunk;
    });

    // 数据接收完毕
    req.addListener('end', function() {
        postData = qs.parse(postData);

        // 跨域后台设置
        res.writeHead(200, {
            'Access-Control-Allow-Credentials': 'true',     // 后端允许发送Cookie
            'Access-Control-Allow-Origin': 'http://www.jxshouse1.club',    // 允许访问的域（协议+域名+端口）
            /* 
             * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，
             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问
             */
            'Set-Cookie': 'l=a123456;Path=/;Domain=www.jxshouse2.club;HttpOnly'  // HttpOnly的作用是让js无法读取cookie
        });

        res.write(JSON.stringify(postData));
        res.end();
    });
});

server.listen('8080');
```

#### 3、   nginx代理跨域
1. nignx配置解决iconfont跨域

浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg) 例外，此时可在nginx的静态资源服务器中加入以下配置。

```bash 
location /{
	ADD_header Access-Control-Allow-Origin *;
}
```
2. nginx反向代理接口跨域

跨域原理：同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行js脚本，不需要同源策略，也就不存在跨域问题。

实现思路：通过nginx配置一个代理服务器（域名与jxshouse相同，端口不同）做跳板机，反向代理访问jxshouse2接口，并且可以顺便修改cookie中的jxshouse信息，方便当前域cookie写入，实现跨域登录。

nginx具体配置:

```
#proxy服务器
server {
    listen       81;
    server_name  www.jxshouse1.com;

    location / {
        proxy_pass   http://www.jxshouse2.com:8080;  #反向代理
        proxy_cookie_domain www.jxshouse2.com www.jxshouse1.com; #修改cookie里域名
        index  index.html index.htm;

        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
        add_header Access-Control-Allow-Origin http://www.jxshouse1.com;  #当前端只跨域不带cookie时，可为*
        add_header Access-Control-Allow-Credentials true;
    }
}
```

前端代码示例：

```
var xhr = new XMLHttpRequest();

// 前端开关：浏览器是否读写cookie
xhr.withCredentials = true;

// 访问nginx中的代理服务器
xhr.open('get', 'http://www.jxshouse.club:81/?user=admin', true);
xhr.send();
```

后台代码示例：
```
var http = require('http');
var server = http.createServer();
var qs = require('querystring');

server.on('request', function(req, res) {
    var params = qs.parse(req.url.substring(2));

    // 向前台写cookie
    res.writeHead(200, {
        'Set-Cookie': 'l=a123456;Path=/;Domain=www.jxshouse.club;HttpOnly'   // HttpOnly:脚本无法读取
    });

    res.write(JSON.stringify(params));
    res.end();
});

server.listen('8080');
console.log('Server is running at port 8080...');
```