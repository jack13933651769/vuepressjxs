# 跨域问题

## 什么是跨域
- 跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。
- 广域的跨域：
```bash
1. 资源跳转： A链接、重定向、表单提交
2. 资源嵌入： <link>、<script>、<img>、<frame>等dom标签，还有样式中background:url()、@font-face()等文件外链
3. 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等
```
- 其实我们说的都是狭义的跨域问题，及浏览器同源策略（因为安全问题），是由浏览器同源策略限制的一类请求场景。
## 什么是同源策略
- 同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也是最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS,CSFR等攻击。所谓同源指 “<font color=red size=4 >协议+域名+端口</font>”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。

- 同源策略限制以下几种行为：
```bash
1. Cookie、LocalStorage 和 IndexDB 无法读取
2. DOM 和 Js对象无法获得
3. AJAX 请求不能发送
```
### 常见的跨域场景

<table>
    <tr>
        <th>URL</th>
        <th>说明</th>
		<th >是否允许通信</th>
    </tr>
    <tr>
        <td>http://www.domain.com/a.js</td>
        <td rowspan="3">  同一域名，不同文件或路径   </td>
		<td rowspan="3">允许</td>
    </tr>
    <tr>
        <td>http://www.domain.com/b.js</td>
    </tr>
    <tr>
        <td>http://www.domain.com/lab/c.js</td>
    </tr>
	<tr>
        <td>http://www.domain.com:8000/a.js</td>
        <td rowspan="2">   同一域名，不同端口     </td>
		<td rowspan="2">不允许</td>
    </tr>
    <tr>
        <td>http://www.domain.com/b.js</td>
    </tr>
	<tr>
        <td>http://www.domain.com/a.js</td>
        <td rowspan="2">   同一域名，不同协议    </td>
		<td rowspan="2">不允许</td>
    </tr>
    <tr>
        <td>https://www.domain.com/b.js</td>
    </tr>
	<tr>
        <td>http://www.domain.com/a.js</td>
        <td rowspan="2">  域名和域名对应相同ip    </td>
		<td rowspan="2">不允许</td>
    </tr>
    <tr>
        <td>http://192.168.4.12/b.js </td>
    </tr>
	    <tr>
        <td>http://www.domain.com/a.js</td>
        <td rowspan="3">  主域相同，子域不同  </td>
		<td rowspan="3">允许</td>
    </tr>
    <tr>
        <td>http://x.domain.com/b.js </td>
    </tr>
    <tr>
        <td>http://domain.com/c.js</td>
    </tr>
	<tr>
        <td>http://www.domain1.com/a.js</td>
        <td rowspan="2">    不同域名      </td>
		<td rowspan="2">不允许</td>
    </tr>
    <tr>
        <td>http://192.168.4.12/b.js </td>
    </tr>
</table>

### 跨域解决方案
```bash
1、 通过jsonp跨域
2、 跨域资源共享（CORS）
3、 nodejs中间件代理跨域
4、 nginx代理跨域 
5、 postMessage跨域 
6、 WebSocket协议跨域
7、 location.hash + iframe 
8、 document.domain + iframe跨域
9、 window.name + iframe跨域
```

#### 1、 通过jsonp跨域

通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。

1.原生js实现
```bash
	<script>
		let script = document.createElement('script');
		script.type = 'text/javascript';
		//传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
		script.src='http://www.jxshouse.club:8080/login?user=admin&callback=handleCallback';
		//回调执行函数
		function handleCallback(res){
			alert(JSON.stringify(res));
		}
	</script>
```
服务端返回如下（返回时即执行全局函数）
```bash
	handleCallback({'status':true,'user':'admin'})
```
后端node.js 代码示例：

```bash
	let querystring = require('querystring');
	let http = require('http');
	let server = http.createServer();

	server.on('request',function(req,res){
		var params = qs.parse(req.url.split('?')[1]);
		var fn = params.callback;

		//jsonp返回设置
		res.writeHead(200,{'Content-Type':'text/javascript'});
		res.write(fn+'('+JSON.stringify(params)+')');
		res.end();
	})
server.listen('8080');
```

jsonp缺点：只能实现get一种请求。

#### 2、  跨域资源共享（CORS）

普通跨域请求：只服务端设置<font color=red size=4 > 响应头 Access-Control-Allow-Origin</font>即可，前端无须设置，若要带cookie请求：前后端都需要设置。

需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：三、nginx反向代理中设置proxy_cookie_domain 和 四、NodeJs中间件代理中cookieDomainRewrite参数的设置。

目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS)，CORS也已经成为主流的跨域解决方案。