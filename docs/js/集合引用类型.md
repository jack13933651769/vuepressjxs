# 集合引用类型

## Obejct

对象创建的实列有两种方式
1. 使用new 操作符和Object构造函数
2. 对象自面量（使用此方法定义对象，并不会实际调用Object函数）
```js
let person = new Object();
person.name = "Nicholas";
person.age = 29;

let person = {
  name: "Nicholas",
  age: 29
};

//获取对象的属性2种方式
console.log(person["name"]); // "Nicholas"//首选使用点语法
console.log(person.name);    // "Nicholas" //访问属性时候需要使用变量用这种方式
```
## Array

创建数组的方式
数组里面可以是数值，字符串，对象
1. 使用new 操作符和Array构造函数
2. 数组自面量（使用此方法定义数组，并不会实际调用Array函数）

```js
let array = new Array();//里面可以添加参数，如果只有一个数值类型的参数是定义数组的长度
let array = Array();//可以省略new
let array1 = [];
```
es6新增两个数组方法

```js
//from()和of()
//from 用于将类数组转换为数组实例，
//of 用于将一组参数转换为数组实例

//new Map() 映射 以键值对的方式
//new Set()去除重复数组
// 可以使用from()将集合和映射转换为一个新数组
const m = new Map().set(1, 2)
                   .set(3, 4);
const s = new Set().add(1)
                   .add(2)
                   .add(3)
                   .add(4);

console.log(Array.from(m)); // [[1, 2], [3, 4]]
console.log(Array.from(s)); // [1, 2, 3, 4]
//浅拷贝
/*
1.只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。
2.像数组里面方法进行浅拷贝，数组里如果有引用类型，修改引用类型新值旧值才会一起改变，如果没修改引用类型是不变的
（换句话说就是数组里面的方法进行浅拷贝第一层，后面第二层开始如果修改是引用类型的话就会跟着变）
*/

// Array.from()对现有数组执行浅拷贝
const a1 = [1, 2, 3, 4];
const a2 = Array.from(a1);
console.log(a1);        // [1, 2, 3, 4]

// arguments对象可以被轻松地转换为数组
function getArgsArray() {
  return Array.from(arguments);
}
console.log(getArgsArray(1, 2, 3, 4)); // [1, 2, 3, 4]

//还可以转自定义对象
// from()也能转换带有必要属性的自定义对象
const arrayLikeObject = {
  0: 1,
  1: 2,
  2: 3,
  3: 4,
  length: 4
};
console.log(Array.from(arrayLikeObject)); // [1, 2, 3, 4]

//from()的第二个参数可以对数组进行修改，第三个可以映射this，箭头函数不适应
const a1 = [1, 2, 3, 4];
const a2 = Array.from(a1, x => x**2);
const a3 = Array.from(a1, function(x) {return x**this.exponent}, {exponent: 2});
console.log(a2);  // [1, 4, 9, 16]
console.log(a3);  // [1, 4, 9, 16]

//of()可以进行将参数转换成数组
console.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4]
```

### 如何检测是不是数组

```js

//第一种  instanceof
if (value instanceof Array){
  // 操作数组
}

//第二种 es6 提供的  isArray函数

if (Array.isArray(value)){
  // 操作数组
}

```
### 数组的迭代器

```js
//三种方法  keys() 索引 values()值 entries()索引+值 

const a = ["foo", "bar", "baz", "qux"];

// 因为这些方法都返回迭代器，所以可以将它们的内容
// 通过Array.from()直接转换为数组实例
const aKeys = Array.from(a.keys());
const aValues = Array.from(a.values());
const aEntries = Array.from(a.entries());

console.log(aKeys);     // [0, 1, 2, 3]
console.log(aValues);   // ["foo", "bar", "baz", "qux"]
console.log(aEntries);  // [[0, "foo"], [1, "bar"], [2, "baz"], [3, "qux"]]



//es6 轻松的解构出键值对
const a = ["foo", "bar", "baz", "qux"];

for (const [idx, element] of a.entries()) {
  alert(idx);
  alert(element);
}
// 0
// foo
// 1
// bar
// 2
// baz
// 3
// qux
```

### 数组的复制和填充方法


```js
//es6新增方法  copyWithin() fill()  使用不会改变数组大小

//fill()
//第一个参数是往数组填充什么值，第二个参数是大于多少，第三个参数是在二参数和三参数之前的进行替换，填负数也会变成正数
//fill()静默忽略超出数组边界、零长度及方向相反的索引范围,部分索引就填充部分
const zeroes = [0, 0, 0, 0, 0];

// 用5填充整个数组
zeroes.fill(5);
console.log(zeroes);  // [5, 5, 5, 5, 5]
zeroes.fill(0);       // 重置

// 用6填充索引大于等于3的元素
zeroes.fill(6, 3);
console.log(zeroes);  // [0, 0, 0, 6, 6]
zeroes.fill(0);       // 重置

// 用7填充索引大于等于1且小于3的元素
zeroes.fill(7, 1, 3);
console.log(zeroes);  // [0, 7, 7, 0, 0];
zeroes.fill(0);       // 重置

// 用8填充索引大于等于1且小于4的元素
// (-4 + zeroes.length = 1)
// (-1 + zeroes.length = 4)
zeroes.fill(8, -4, -1);
console.log(zeroes);  // [0, 8, 8, 8, 0];

//copyWithin() 一个参数时候，从0到这个参数进行复制然后在这个参数后进行插入，直到插入到数组边界
//两个参数的话就是  第一位插入的位置，第二位是从这个参数开始进行复制
//三个参数的话，第一个插入位置第二个从第几个开始第三个是到那个位置结束


```

### 数组转换方法(对象都有这几个方法)
 所有对象都有这些方法
```js
toLocaleString()
toString()//由逗号分隔的字符串
valueOf()  //返回数组本身
//toLocaleString()和toString() 有区别的，当转换数字时候toLocaleString会3个数字前会加逗号， 转换时间也是不同的

//toLocaleString()  toString()转换成字符串 都是以逗号分隔 如果不想用逗号分隔 可以使用 join函数进行替换
//join()是数组函数，
let arr = [1,2,3,4]
console.log(arr.join('|'))  //"1|2|3|4"

```
### 数组栈方法
```js
// push() pop()
//像栈一样， 限制插入和删除的数据结构，只能有同一个出入口   后进先出 （Last-in-first-out）的结构 
//数据插入 (称为push) 数据删除（称为pop） ，无论是删除还是插入都在同一个地方发生，即栈顶
//类似乒乓球盒子 最下面的是1 最顶上的是5  每次都在顶部插入和删除

//push 可以接受任意数量的参数，并将它们添加到数组末尾
let colors = new Array();                 // 创建一个数组
let count = colors.push("red", "green");  // 推入两项
alert(count);                             // 2

count = colors.push("black");  // 再推入一项
alert(count);                  // 3
//pop 用于删除数组的最后一项，同时减少数组的length值，返回呗删除的项

let item = colors.pop();       // 取得最后一项  3
alert(item);                   // black
alert(colors.length);  //2

```
![avatar](../img/zhan.jpg)


### 数组列队方法

```js
//限制访问的数据结构，队列以先进先出(FIFO, First-In-First-Out)形式限制访问
//队列是在列表末尾添加数据 但从开头进行获取数据。
//末尾添加  push()
//开头获取  shift() ，它删除数组的第一项并返回它，在数组长度减1，  使用shift和push可以把数组当队列使用

let colors = new Array();                 // 创建一个数组
let count = colors.push("red", "green");  // 推入两项
alert(count);                             // 2

count = colors.push("black"); // 再推入一项
alert(count);                 // 3

let item = colors.shift();  // 取得第一项
alert(item);                // red
alert(colors.length);       // 2
/*

反向队列 可以使用  unshift 和pop 一起使用。
unshift是从头部开始添加多个任意值，返回新的数组长度，
*/


let arr = ['a','b'];
arr.unshift('c','d');
console.log(arr) //c,d,a,b
```
![avatar](../img/duilie.jpg)


<a href="https://www.cnblogs.com/slly/p/10366290.html" >js中的栈、堆、队列、内存空间</a>

### 数组排序方法

```js
//reverse()反转和sort()排序

let arr = [1,2,3,4,5];
consolse.log(arr.severse())//5,4,3,2,1


let arr2 = [1,11,5,4,13,23];

console.log(arr2.sort())//1,11,13,23,4,5
// 注意 sort 排序是从第一位数字开始对比排序

```
### 操作方法

```js
//concat slice  splice 
//concat 连接
/*
将现有数组全部元素得基础上创建一个新的数组，先创建当前数组的副本，在把他的参数添加嗷副本末尾，最后返回新构建的数组
如果传入多个数组，则会把这些数组的而每一项都添加到结果数组中，如果不是数组，则直接把他们添加到结构数组末尾。

如果不想打平数组可以 通过Symbol改变
*/

let colors = ["red", "green", "blue"];
let newColors = ["black", "brown"];
let moreNewColors = {
  [Symbol.isConcatSpreadable]: true,
  length: 2,
  0: "pink",
  1: "cyan"
};

newColors[Symbol.isConcatSpreadable] = false;//不大平数组的参数 利用Symbol.isConcatSpreadable

// 强制不打平数组
let colors2 = colors.concat("yellow", newColors);

// 强制打平类数组对象
let colors3 = colors.concat(moreNewColors);

console.log(colors);   // ["red", "green", "blue"]
console.log(colors2);  // ["red", "green", "blue", "yellow", ["black", "brown"]]
console.log(colors3);  // ["red", "green", "blue", "pink", "cyan"]


/*
slice() 创建一个包含原有数组中一个或多个元素的新数组。
可以接受一个或者两个参数， 返回元素的开始索引和结束索引
1个参数，返回从开始索引到结束索引的所有元素，不包含当前索引的元素，不会影响原始 数组。
2个参数 silce 反不会从开始到结束索引的所有元素，不包含结束所有对应的元素。
不会对原始数组有影响

*/

let colors = ["red", "green", "blue", "yellow", "purple"];
let colors2 = colors.slice(1);
let colors3 = colors.slice(1, 4);

alert(colors2);  // green,blue,yellow,purple
alert(colors3);  // green,blue,yellow

/*
slice  可以使用负值， 如果有负值 那么就以长度加上这个负值的结果确定位置，
如果5个元素的数组 ，alice(-2,-1) = sliec(3,4)
如果结束位置小于开始位置，则返回空数组
*/
```
```js
//splice()//很强大的方法

//删除  splice()，需要传2个参数，删除的第一个元素位置和要删除的元素的数量。
//插入 splice()， 传3个参数，开始位置，0（要删除的元素数量），和要插入的元素
//替换 splice()，传三个参数，开始位置，要替换的元素数量，要插入的任意多个元素
```

