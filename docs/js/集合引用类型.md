# 集合引用类型

## Obejct

对象创建的实列有两种方式
1. 使用new 操作符和Object构造函数
2. 对象自面量（使用此方法定义对象，并不会实际调用Object函数）
```js
let person = new Object();
person.name = "Nicholas";
person.age = 29;

let person = {
  name: "Nicholas",
  age: 29
};

//获取对象的属性2种方式
console.log(person["name"]); // "Nicholas"//首选使用点语法
console.log(person.name);    // "Nicholas" //访问属性时候需要使用变量用这种方式
```
## Array

创建数组的方式
数组里面可以是数值，字符串，对象
1. 使用new 操作符和Array构造函数
2. 数组自面量（使用此方法定义数组，并不会实际调用Array函数）

```js
let array = new Array();//里面可以添加参数，如果只有一个数值类型的参数是定义数组的长度
let array = Array();//可以省略new
let array1 = [];
```
es6新增两个数组方法

```js
//from()和of()
//from 用于将类数组转换为数组实例，
//of 用于将一组参数转换为数组实例

//new Map() 映射 以键值对的方式
//new Set()去除重复数组
// 可以使用from()将集合和映射转换为一个新数组
const m = new Map().set(1, 2)
                   .set(3, 4);
const s = new Set().add(1)
                   .add(2)
                   .add(3)
                   .add(4);

console.log(Array.from(m)); // [[1, 2], [3, 4]]
console.log(Array.from(s)); // [1, 2, 3, 4]
//浅拷贝
/*
1.只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。
2.像数组里面方法进行浅拷贝，数组里如果有引用类型，修改引用类型新值旧值才会一起改变，如果没修改引用类型是不变的
（换句话说就是数组里面的方法进行浅拷贝第一层，后面第二层开始如果修改是引用类型的话就会跟着变）
*/

// Array.from()对现有数组执行浅拷贝
const a1 = [1, 2, 3, 4];
const a2 = Array.from(a1);
console.log(a1);        // [1, 2, 3, 4]

// arguments对象可以被轻松地转换为数组
function getArgsArray() {
  return Array.from(arguments);
}
console.log(getArgsArray(1, 2, 3, 4)); // [1, 2, 3, 4]

//还可以转自定义对象
// from()也能转换带有必要属性的自定义对象
const arrayLikeObject = {
  0: 1,
  1: 2,
  2: 3,
  3: 4,
  length: 4
};
console.log(Array.from(arrayLikeObject)); // [1, 2, 3, 4]

//from()的第二个参数可以对数组进行修改，第三个可以映射this，箭头函数不适应
const a1 = [1, 2, 3, 4];
const a2 = Array.from(a1, x => x**2);
const a3 = Array.from(a1, function(x) {return x**this.exponent}, {exponent: 2});
console.log(a2);  // [1, 4, 9, 16]
console.log(a3);  // [1, 4, 9, 16]

//of()可以进行将参数转换成数组
console.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4]
```
