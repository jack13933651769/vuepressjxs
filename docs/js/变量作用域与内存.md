# 变量,作用域与内存

## 变量有两种类型的数据: 原始值和引用值

原始值(primitive value):就是简单数据

原始值：Undefined Null Bollean Number String Symbol
保存原始值变量是按值 访问的，我们操作的就是存储在变量中的实际值

引用值(reference value):由多个值构成的对象

引用值是访问在内存中的对象，实际操作也是对改对象的引用并不是对象的本身，引用值得变量是按引访问的

```js
//引用类型可以随时添加,修改,删除起属性和方法
let person = new Object();
person.name = 'a'
console.log(person.name);//a

let people = 'haha';
people.name = 'zhanshan'
console.log(people.name)//undefiend//原始值不能有属性，虽然不会报错但是取不到值

//虽然原始值不能拿到，但是可以通过 new 进行对初始值进行包装，这样 typeof就不再是原始值类型而是object
let name1 = "Nicholas";
let name2 = new String("Matt");
name1.age = 27;
name2.age = 26;
console.log(name1.age);//拿不到 undefiend  
console.log(name2.age); //能拿到 26
```
<table>
<tr>
<td>类型</td>
<td>区别</td>
</tr>
<tr>
<td>原始值</td>
<td>1.不能有属性2.复制值时候，两个变量可以对立使用，互不干扰</td>
</tr>
<tr>
<td>引用值</td>
<td>1.可以随意修改添加删除属性2.复制值时候，两个变量实际上是同一个指针，它指向存储在堆内存中的对象，修改任意一个，另一个也会变</td>
</tr>
</table>

## 参数传递

在函数里 参数传递，无论是原始值还是引用值，都是按照值来传递的。
```js
function addTen(num) {  
  num += 10;  
  return num; 
} 
let count = 20;
let result = addTen(count);
console.log(count);  // 20，没有变化 console.log(result); // 30 


function setName(obj) {
    obj.name = "Nicholas";  //因为是安装值传递，里面还是引用类型的属性或值所以外面可以拿到传递的值
}  
let person = new Object();
setName(person); 
console.log(person.name);  // "Nicholas" 

function setName(obj) { 
obj.name = "Nicholas";
obj = new Object();//因为传递是按照值传递的，所以传递引用类型是不可以的。
obj.name1 = "Greg"; 
}  
let person = new Object();
setName(person); 
console.log(person.name,person.name1);  // "Nicholas  undefined" 
```

## 确定类型

```js
typeof //判断一个变量是否为原始类型
//缺点  只能判断 字符串，数值，布尔值，undefined 
//如果是null 会返回object
instanceof //可以解决这个typeof的问题  用来解决 判断引用类型
console.log(person instanceof Object);  // 变量person是Object吗？
console.log(colors instanceof Array);   // 变量colors是Array吗？ 
console.log(pattern instanceof RegExp); // 变量pattern是RegExp吗？ 
```

## 执行上下文与作用域





