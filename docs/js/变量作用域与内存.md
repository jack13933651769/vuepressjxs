# 变量,作用域与内存

## 变量有两种类型的数据: 原始值和引用值

原始值(primitive value):就是简单数据

原始值：Undefined Null Bollean Number String Symbol
保存原始值变量是按值 访问的，我们操作的就是存储在变量中的实际值

引用值(reference value):由多个值构成的对象

引用值是访问在内存中的对象，实际操作也是对改对象的引用并不是对象的本身，引用值得变量是按引访问的

```js
//引用类型可以随时添加,修改,删除起属性和方法
let person = new Object();
person.name = 'a'
console.log(person.name);//a

let people = 'haha';
people.name = 'zhanshan'
console.log(people.name)//undefiend//原始值不能有属性，虽然不会报错但是取不到值

//虽然原始值不能拿到，但是可以通过 new 进行对初始值进行包装，这样 typeof就不再是原始值类型而是object
let name1 = "Nicholas";
let name2 = new String("Matt");
name1.age = 27;
name2.age = 26;
console.log(name1.age);//拿不到 undefiend  
console.log(name2.age); //能拿到 26
```
<table>
<tr>
<td>类型</td>
<td>区别</td>
</tr>
<tr>
<td>原始值</td>
<td>1.不能有属性2.复制值时候，两个变量可以对立使用，互不干扰</td>
</tr>
<tr>
<td>引用值</td>
<td>1.可以随意修改添加删除属性2.复制值时候，两个变量实际上是同一个指针，它指向存储在堆内存中的对象，修改任意一个，另一个也会变</td>
</tr>
</table>

## 参数传递

在函数里 参数传递，无论是原始值还是引用值，都是按照值来传递的。
```js
function addTen(num) {  
  num += 10;  
  return num; 
} 
let count = 20;
let result = addTen(count);
console.log(count);  // 20，没有变化 console.log(result); // 30 


function setName(obj) {
    obj.name = "Nicholas";  //因为是安装值传递，里面还是引用类型的属性或值所以外面可以拿到传递的值
}  
let person = new Object();
setName(person); 
console.log(person.name);  // "Nicholas" 

function setName(obj) { 
obj.name = "Nicholas";
obj = new Object();//因为传递是按照值传递的，所以传递引用类型是不可以的。
obj.name1 = "Greg"; 
}  
let person = new Object();
setName(person); 
console.log(person.name,person.name1);  // "Nicholas  undefined" 
```

## 确定类型

```js
typeof //判断一个变量是否为原始类型
//缺点  只能判断 字符串，数值，布尔值，undefined 
//如果是null 会返回object
instanceof //可以解决这个typeof的问题  用来解决 判断引用类型
console.log(person instanceof Object);  // 变量person是Object吗？
console.log(colors instanceof Array);   // 变量colors是Array吗？ 
console.log(pattern instanceof RegExp); // 变量pattern是RegExp吗？ 
```

## 执行上下文与作用域
执行上下文又称 上下文<br>
变量和函数的上下文决定了他们可以访问那些数据，以及他们的行为。<br>
每一个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上。<br>
全局上下文是外层的上下文，全局上下文就是我们常说的window对象，因此通过 var定义的全局变量和函数都会成为window对象的属性和方法。（let和const的顶级声明不会定义在全局上下文中，但在作用域解析上效果是一样。）<br>
上下文会在其所有代码都执行完毕后会被销毁，包括里面定义的 属性和方法，全局上下午在应用程序退出会被销毁（关闭网页和退出浏览器）<br>
每个函数调用都有自己的上下文，当代码执行流进入函数时候，函数的上下文被推到一个上下文栈上<br>
当函数执行完毕，会弹出改函数上下文，将控制权还给之前的执行上下文。<br>
js程序的执行流是通过上下文栈进行控制的，上下文的代码执行时候会创建一个变量对象的一个作用域链。作用域链决定各级上下文的代码在访问属性和函数时候的顺序。  <br>
正在执行的上下文的变量对象始终位于作用域链的前端。<br>
如果上下文是函数，则其活动对象用作变量对象。活动对象初只有一个定义变量：arguments，顺着作用域链一级一级找，找到全局上下文为止。

```js
var color = "blue";  //     全局上下文
 function changeColor() {   let anotherColor = "red"; //局部上下文
 
  function swapColors() {   //局部上下文
    let tempColor = anotherColor;  
    anotherColor = color;
    color = tempColor; 
 
    // 这里可以访问color、anotherColor和tempColor //能访问到是因为内部上下文可以通过作用域链访问外部上下文中的一切。
  } 
  // 这里可以访问color和anotherColor，但访问不到tempColor   swapColors(); //这里相对于 swapColors是外部上下文，是无法访内部上下文的内部任何东西
} 
```
作用域链增强

执行上下文一般有两种：全局和函数上下文（eval()调用内部存在的第三种上下文）<br>
但又其他方式来增强作用域链。 某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。
1. try/catch语句的catch块<br>
2. with语句


## 变量声明

1. var
1.使用var 的函数作用域声明<br>
在使用 var 声明变量时候，变量会被自动添加到接近的上下文，在函数中，接近的而上下文就是函数的局部上下文<br>
2.var 声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫做‘提升’<br>

```js
var name = 'Jake';
// 等价于： 
 name = 'Jake'; var name; 
//下面是两个等价的函数： 
function fn1() {    var name = 'Jake'; 
} 
// 等价于： 
function fn2() {   var name;   name = 'Jake'; 
} 
```

2. let 块级作用域声明

```js




```
